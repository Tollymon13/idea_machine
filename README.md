# The Start-up Machine

#### Video Demo:  <https://youtu.be/lp_6tUxJFG0>

#### Description:
The project, named "The Start-up Machine" is meant to help future innovators in coming up with potential ideas for start-ups. It contains a variety of functions, each with a specific purpose of helping with boosting creativity. I have been looking for something similar for a while, but I could not find it. Even, though it has limited functionalities, the main purpose of the program (i.e. Come up with random ideas) is achieved. Throughout the project, I used as much as possible, most of the concepts learned during the lectures.

The class "Startup" and its subsequent functions represents the bolts and nuts of the project itself.

The method "starts" will ask for an industry to be selected from a list of already curated industries initialized at the beginning of the project. To make use of regular expressions, I ask the user to input the string into a specific format (i.e. "[industry]"). If the user does not comply, the program will ask for the correct input again, by using a while loop. When the input matches the correct format, then the introduced industry will be checked against the list of industries already initialized. Again, if the user introduces the wrong industry, then the program will quickly re-prompt. The method "get_niche(industry)" is meant to return back to the user, a random niche from a list declared beforehand. This uses a match function, and based on the input it returns a random choice of a niche based on the selected industry. Note, that the library random is being used to achieve the random selection. Now, the user will have an industry and niche selected, and the method "starts" will return back both variable to be used in a separate method.

The method "combine" will return the statement including all the previously generate variables. All the values are passed as arguments to the method, and accessed using an f-string. The result is returned as a string of texts, that will display the random start-up idea.

The method "feature" is meant to open a specific .csv file that contains features to be considered during the generation of the random start-up idea. I have included just a limited number of features, namely the unique selling point (i.e. USP), the allocated time to come up with a business strategy/prototype, the budget for the project and the monetization technique employed. It uses DictReader to get the reader object and a for loop to go through each row, appending the values into a list of dictionaries. Then, using a list comprehension, I grab each feature value and place them in individual lists. All the values are then returned to the main program. I explain lower below, why I chose to read them from a .csv file.

The method "get_feature(feature)" is meant to select a random value from the passed feature list. It uses the random library to select a random integer, and index the passed list. I chose to make the features random, so that the user can experience an "explosion" in creativity.

One distinct design choice was to use lists for the 'industries' and 'niche' variables declared at the beginning of the project. They are fine for a small project like this, but if I want to expand on the amount of industries/niches to choose from, then maybe a text file or .csv would have been more appropriate. My decision to allow only a small number of industries/niches was just to prove the concept. However, to put it in comparison, I have chosen deliberately to integrate the variables 'usp', 'time', 'budget' and 'monetization' by reading them from a .csv file. It is much more easier to expand the amount of variety in these features by directly accessing the values from a file.

"this_that_generator" is a method that uses an API to return two specific values, namely "this" representing a famous start-up/technology/trend and "that" representing random keywords. The whole concept of this method is to make way for creativity and promote never heard before concepts. For example, you might be getting "Netflix for magazines", and the user can interpret this in various ways and potentially make a start-up around it.

"hacker_news" function, takes in an argument "n", that represents the number of news one wants to have written in the file. Otherwise, the function will keep pulling all the news stories from the website and that will take a few minutes. I get the response from the url (i.e. Make a request), then I have the stories contents pulled from the website in .json form. However, I also use .loads to make the contents a list that is inerrable. That is because, I need to all the news into individual stories that I can access and then iterate over. I pull the "url" and "title" for each of the stories and write them in a file called "news.txt". Note, that I made sure to include only the stories that have urls (i.e. The if statement), because there are some of them that do not contain an url. At the end of the function, I return the number of stories pulled to make that it matches the number of stories wished at the beginning of the program. This is a feature, because as the number of stories increases, it because harder to see if the program wrote the number of stories successfully.

"get_startups_list" is meant to print a list of written start-ups and their description in a grid table format. It asks the user for the specific file name, and then it opens it up using DictReader. Each row will then be appended to a list of victories. Then, each of these values will be pulled from the dictionary, transformed into a list and appended to a list variable. The reason for this is because the tabulate function, takes in a list of all the values and a list of the fieldnames. At the end of the function, I return the read table back to the user. I have also included the exception of the file not existing, just in case the user makes a mistake.

"add_startups_list(name, desc, x)" adds to/create a list of start-up names and their description. First, checks if the length of the description matches the required 5 characters, otherwise it indicates to the user that the string is too long. If the file happens to be not ending in .csv, the function forces the program to exit as well. Also, if the file does not exist, then the function will raise a flag that will allow the writer object to write the table's headers. If the file exists, it is assumed that the headers have been already written correctly, and they are omitted from being written every time a new start-up is being added.

In the main function, I have made a small menu with various options. Based on the input of the user, the program will run specific methods. I did not make it into a while loop, because it might confuse the user to keep getting prompted or force them to use something like "cntrl + d" to exit the program.
